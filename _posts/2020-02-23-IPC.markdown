---
layout: post
title:  "进程间通信（Inter Process Communication）"
description: 进程间通信（Inter Process Communication）
date:   2020-12-23 20:09:36 +0530
categories: Linux
---
​		Linux环境下，进程地址空间相互独立，每个进程各自有不同的用户地址空间。任何一个进程的全局变量在另一个进程中都看不到，所以进程和进程之间不能相互访问，要交换数据必须通过内核，在内核中开辟一块缓冲区，进程1把数据从用户空间拷到内核缓冲区，进程2再从内核缓冲区把数据读走，内核提供的这种机制称为进程间通信（IPC，Inter Process Communication）。 

![ipc](F:\qpointwang.github.io\_pic\ipc.png)

​		在进程间完成数据传递需要借助操作系统提供特殊的方法，如：管道、命名管道、信号、消息队列、共享内存、信号量、套接字等。随着计算机的蓬勃发展，一些方法由于自身设计缺陷被淘汰或者弃用。现今常用的进程间通信方式有： 

1. 管道 (使用最简单)
2. 信号 (开销最小)
3. 共享映射区 (无血缘关系)
4. 本地套接字 (最稳定)

### 进程间通信的7种方式

#### 1. 管道(pipe)

- 管道是半双工，数据只能向一个方向流动；双方需要互相通信时，需要建立起两个管道。
- 只能用于具有亲缘关系的进程（父子进程或者兄弟进程）之间。
- 管道对于两端通信的进程来说就只是一种文件，**一种不属于文件系统仅存在内存中的“伪文件”**。
- 管道的通信方式为：写端每次都将数据写入管道缓冲区的 **末尾** ，而读端每次都从管道缓冲区的 **头部** 读出数据。

##### 管道的实质

​		管道的实质是内核利用 **环形队列** 的数据结构在 **内核缓冲区** 中的一个实现，默认设置大小为4K，可以通过`ulimit -a`命令查看。由于利用 **环形队列** 进行实现，读和写的位置都是自动增长的，不能随意改变，一个数据只能被读取一次，读取后数据就会从缓冲区中移除。当缓冲区读空或者写满时，有一定的规则控制相应的读进程或者写进程进入等待队列，当空的缓冲区有新数据写入或者满的缓冲区有数据读出来时，就唤醒等待队列中的进程继续读写。

##### 管道的局限

- 由于管道采用半双工通信方式。因此，只支持单向数据流。
- 只能由于具有亲缘关系的进程。
- 管道的缓冲区大小有限。
- 没有名称。

#### 2. 命名管道(FIFO)

​		FIFO常被称为命名管道，以区分管道(pipe)。管道(pipe)只能用于“有血缘关系”的进程间。但通过FIFO，不相关的进程也能交换数据。命名管道不同于匿名管道之处在于它提供了一个路径名与之关联，以命名管道的文件形式存在于文件系统中，这样，即使与命名管道的创建进程不存在亲缘关系的进程，只要可以访问该路径，就能够彼此通过命名管道相互通信，因此，**通过命名管道不相关的进程也能交换数据**。值的注意的是，命名管道严格遵循先进先出(first in first out)，对匿名管道及有名管道的读总是从开始处返回数据，对它们的写则把数据添加到末尾。它们不支持诸如lseek()等文件定位操作。**命名管道的名字存在于文件系统中，内容存放在内存中**。

##### 匿名管道和命名管道总结

1. 管道是特殊类型的文件，在满足先入先出的原则条件下可以进行读写，但不能进行定位读写。
2. 匿名管道是单向的，只能在有亲缘关系的进程间通信；有名管道以磁盘文件的方式存在，可以实现本机任意两个进程通信。
3. 无名管道阻塞问题：无名管道无需显示打开，创建时直接返回文件描述符，在读写时需要确定对方的存在，否则将退出。如果当前进程向无名管道的一端写数据，必须确定另一端有某一进程。如果写入无名管道的数据超过其最大值，写操作将阻塞，如果管道中没有数据，读操作将阻塞，如果管道发现另一端断开，将自动退出。
4. 命名管道阻塞问题：命名管道在打开时需要确实对方的存在，否则将阻塞。即以读方式打开某管道，在此之前必须一个进程以写方式打开管道，否则阻塞。此外，可以以读写（O_RDWR）模式打开命名管道，即当前进程读，当前进程写，不会阻塞。

#### 3. 信号(signal)

- 信号是Linux系统中用于进程间互相通信或者操作的一种机制，信号可以在任何时候发给某一进程，而无需知道该进程的状态。
- 如果该进程当前并未处于执行状态，则该信号就有内核保存起来，直到该进程恢复执行并传递给它为止。
- 如果一个信号被进程设置为阻塞，则该信号的传递被延迟，直到其阻塞被取消是才被传递给进程。

##### 信号来源

​		信号是软件层次上对中断机制的一种模拟，是一种异步通信方式，信号可以在用户空间进程和内核之间直接交互，内核可以利用信号来通知用户空间的进程发生了哪些系统事件，信号事件主要有两个来源：

- 硬件来源：用户按键输入 `Ctrl+C` 退出、硬件异常如无效的存储访问等。
- 软件终止：终止进程信号、其他进程调用 `kill` 函数、软件异常产生信号。

##### 信号生命周期和处理流程

1. 信号被某个进程产生，并设置此信号传递的对象（一般为对应进程的pid），然后传递给操作系统；
2. 操作系统根据接收进程的设置（是否阻塞）而选择性的发送给接收者，如果接收者阻塞该信号（且该信号是可以阻塞的），操作系统将暂时保留该信号，而不传递，直到该进程解除了对此信号的阻塞（如果对应进程已经退出，则丢弃此信号），如果对应进程没有阻塞，操作系统将传递此信号。
3. 目的进程接收到此信号后，将根据当前进程对此信号设置的预处理方式，暂时终止当前代码的执行，保护上下文（主要包括临时寄存器数据，当前程序位置以及当前CPU的状态）、转而执行中断服务程序，执行完成后在回复到中断的位置。当然，对于抢占式内核，在中断返回时还将引发新的调度。

#### 4. 消息队列(message)

- 消息队列是存放在内核中的消息链表，每个消息队列由消息队列标识符表示。
- 与管道（无名管道：只存在于内存中的文件；命名管道：存在于实际的磁盘介质或者文件系统）不同的是消息队列存放在内核中，只有在内核重启(即，操作系统重启)或者显示地删除一个消息队列时，该消息队列才会被真正的删除。
- 另外与管道不同的是，消息队列在某个进程往一个队列写入消息之前，并不需要另外某个进程在该队列上等待消息的到达

> 消息队列特点总结：
>
> 1. 消息队列是消息的链表,具有特定的格式,存放在内存中并由消息队列标识符标识.
> 2. 消息队列允许一个或多个进程向它写入与读取消息
> 3. 管道和消息队列的通信数据都是先进先出的原则。
> 4. 消息队列可以实现消息的随机查询,消息不一定要以先进先出的次序读取,也可以按消息的类型读取.比FIFO更有优势。
> 5. 消息队列克服了信号承载信息量少，管道只能承载无格式字 节流以及缓冲区大小受限等缺。
> 6. 目前主要有两种类型的消息队列：POSIX消息队列以及System V消息队列，System V消息队列目前被大量使用。System V消息队列是随内核持续的，只有在内核重起或者人工删除时，该消息队列才会被删除。

#### 5. 共享内存（SHARE MEMORY）

- 使得多个进程可以可以直接读写同一块内存空间，是最快的可用IPC形式。是针对其他通信机制运行效率较低而设计的。
- 为了在多个进程间交换信息，内核专门留出了一块内存区，可以由需要访问的进程将其映射到自己的私有地址空间。进程就可以直接读写这一块内存而不需要进行数据的拷贝，从而大大提高效率。
- 由于多个进程共享一段内存，因此需要依靠某种同步机制（如信号量）来达到进程间的同步及互斥。

#### 6. 信号量（SEMAPHORE）

信号量是一个计数器，用于多进程对共享数据的访问，信号量的意图在于进程间同步。
为了获得共享资源，进程需要执行下列操作：

1. 创建一个信号量：这要求调用者指定初始值，对于二值信号量来说，它通常是1，也可是0。
2. 等待一个信号量：该操作会测试这个信号量的值，如果小于0，就阻塞。也称为P操作。
3. 挂出一个信号量：该操作将信号量的值加1，也称为V操作。

为了正确地实现信号量，信号量值的测试及减1操作应当是原子操作。为此，信号量通常是在内核中实现的。Linux环境中，有三种类型：Posix（可移植性操作系统接口）有名信号量（使用Posix IPC名字标识）、Posix基于内存的信号量（存放在共享内存区中）、System V信号量（在内核中维护）。这三种信号量都可用于进程间或线程间的同步。

##### 信号量与互斥量之间的区别

1. 互斥量用于线程的互斥，信号量用于线程的同步。这是互斥量和信号量的根本区别，也就是互斥和同步之间的区别。

   **互斥**：是指某一资源同时只允许一个访问者对其进行访问，具有唯一性和排它性。但互斥无法限制访问者对资源的访问顺序，即访问是无序的。

   **同步**：是指在互斥的基础上（大多数情况），通过其它机制实现访问者对资源的有序访问。

   在大多数情况下，同步已经实现了互斥，特别是所有写入资源的情况必定是互斥的。少数情况是指可以允许多个访问者同时访问资源

2. 互斥量值只能为0/1，信号量值可以为非负整数。

   也就是说，一个互斥量只能用于一个资源的互斥访问，它不能实现多个资源的多线程互斥问题。信号量可以实现多个同类资源的多线程互斥和同步。当信号量为单值信号量是，也可以完成一个资源的互斥访问。

3. 互斥量的加锁和解锁必须由同一线程分别对应使用，信号量可以由一个线程释放，另一个线程得到。

#### 7. 套接字（SOCKET）

 		套接字是一种通信机制，凭借这种机制，客户/服务器（即要进行通信的进程）系统的开发工作既可以在本地单机上进行，也可以跨网络进行。也就是说它可以让不在同一台计算机但通过网络连接计算机上的进程进行通信。 套接字是支持TCP/IP的网络通信的基本操作单元，可以看做是不同主机之间的进程进行双向通信的端点，简单的说就是通信的两方的一种约定，用套接字中的相关函数来完成通信过程。 